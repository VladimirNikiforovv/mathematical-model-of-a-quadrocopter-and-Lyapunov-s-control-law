Проект выведенной мной математической модели динамических уравнений квадрокоптера учитывающий тензоры инерции, сложное угловое движение, и реализацию поворотов через кватернионы. А также выведенное к этой модели адаптивное асимптотическое управление по Ляпунову. 
файл с описанием вывода уравнений: "model and control output"

Описан алгоритм симуляции движения, выполненный в виде класса python, реализующий моделирование полной динамики во времени, через численное решение соответствующей системы дифференциальных уравнений методом Рунге-Кутты 4го порядка, и часть управления, рассчитанная методом многомерной оптимизации через библиотеку SciPy, остальные вычисления описаны моими алгоритмами при помощи NumPy, а символьное вычисление перехода к компонентному виду уравнений и частичный вывод уравнений, автоматизирован через библиотеку символьных вычислений SymPy в соответствующем скрипте в юпитер ноутбуке.

Отображение динамики реализовано через matplotlib.animation как метод класса, и отображает динамику движения в 3д включая повороты, и центральное движение, а через matplotlib.pyplot реализовано отображение динамических переменных по вызову соответствующего метода.

В репозитории есть два файла запустив которые можно посмотреть на результат работы это main_exempl.py и main_lyapunov_control.py, так же в репозитории есть картинки, которые отображают результат работы алгоритмов.

Как пользоваться моделью квадрокоптера и вычисления управления:

from quadrocopter_dynamics_simulation import *

from quadrocopter_lyapunov_control import *

Сначала нужно инициировать количество итераций и шаг по времени.

N = 3000

h = 0.01

Далее задать возмущающие моменты, например, нулями:

Mext = np.zeros((3,N))

После задать начальные условия задачи Коши, то есть стартовые координаты, импульсы, угловые скорости, и начальные кватернионы рекомендую $q_0 = 1, q_1 = 0, q_2 = 0, q_3 = 0$, 
так же указать начальный суммарный момент лопастей u_init

w_init = np.array([0,0,0])

q_init = np.array([1,0,0,0])

p_init = np.array([0,0,0])

r_init = np.array([0,0,0])

u_init = np.array([0,0,0,0])

Определить желаемые импульсы как функцию от времени.

p_like_cont = np.zeros((3,N))

t = np.linspace(0, h*N,N)

p_like_cont[2,:500] =  1

Создать объект управления

QQ1 = quadrocopter_control() 

Задать в него возмущения

QQ1.perturbation(Mext)

Ввести все переходные параметры в метод control_calc, от в свою очередь вычислит закон управления

QQ1.control_calc(h, N, w_init, q_init, p_init, u_init, 0.2, 0.3, 7, p_like_cont)

Создать объект квадрокоптер, и передать ему возмущения и управления через соответствующие методы perturbation и control

QQ2 = quadrocopter()        

QQ2.perturbation(Mext)

QQ2.control(QQ1.ww_h)

ww_h - это массив содержащий скорости винтов как функции от времени, первый индекс массива соответствует номеру винта

Далее вызвать метод симуляции передав ей все необходимые значения для решения задачи Коши

QQ2.motion_simulation(h, N, w_init, q_init, p_init, r_init)

Для отображения есть метод вызова графиков динамических переменных от времени

QQ2.motion_pattern_graph()

Или вызов удобной анимации углового и центрального движения

QQ2.simulation_animate()
